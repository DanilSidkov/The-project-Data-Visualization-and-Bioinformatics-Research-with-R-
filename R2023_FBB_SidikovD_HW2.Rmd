---
title: "ФББ - R - Домашнее задание №2"
author: "Данил Сидиков"
date: "19.09.2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
***
# Подгрузка пакетов


```{r}
library('tidyverse') #загрузим установленный пакет tidyverse в текущую R сессию
library("openintro") #загрузим установленный пакет openintro в текущую R сессию для работы с датасетом nycflights
```
***
# Задание №1

>Воспользуйтесь набором данных **nycflights** из пакета **openintro**.
>Примените к данным **nycflights** функцию **glimpse()**.

>Выведите результат полностью.

```{r}
head(nycflights)
glimpse(nycflights) # применим функцию glimpse()
``` 
# Задание №2

>Есть ли в данных **nycflights** пропущенные значения?

>Используя функции **базового R** выведите сумму пропущенных значений в наборе данных.

```{r}
anyNA(nycflights) # Есть ли пропущенные значения?
sum(is.na(nycflights)) # Сумма пропущенных значений
```
# Задание №3

>Для фильтрации строк по условию используйте функцию **filter()**.

>Отберите из набора данных ***nycflights** **июньские** (столбец month) рейсы, которые вылетели (столбец origin) из аэропорта **JFK** и прилетели (столбец dest) в аэропорты **LAX** или **ROC**. Выполните фильтрацию за одну команду. Покажите, что вы точно отобрали только нужные аэропорты.

>Сколько рейсов подходят под условия?

```{r}
sort_flights <- filter(nycflights, month == 6 & origin == 'JFK' & (dest == "LAX" | dest == "ROC")) # отберем данные по условию
#Убедимся, что мы точно отобрали, то что нужно
table(sort_flights$month)
table(sort_flights$origin)
table(sort_flights$dest)
dim(sort_flights)[1] # столько рейсов подходят под условия
```

# Задание №4

>Для выбора колонок по индексу и имени используйте функцию **select()**
>Давайте начнем с **индексов**.
>Воспользуйтесь подвыборкой рейсов, полученных в задании №3.
>Отберите наиболее оптимальным способом первую, вторую, третью, одиннадцатую и двенадцатую колонки.

```{r}
head(sort_flights) # подвыборка рейсов из задания №3
sq <- sort_flights
super_sort = select(sq, c(1,2,3,11,12)) #отоберем колонки по индексу с помощью вектора
head(super_sort) # теперь это наша подвыборка задания №4
```

# Задание №5

>Теперь отберем колонки по **имени**.
>Воспользуйтесь подвыборкой рейсов, полученных в задании №3.

>Удалите колонку с аэропортами, куда прилетали рейсы.

```{r}
head(sort_flights) # подвыборка рейсов из задания №3
sq <- sort_flights
sort2 = select(sq, year, month, day, origin, dest) #отоберем колонки по имени
head(sort2)
sort2$dest = NULL # удалим колонку с аэропортами, куда прилетали рейсы
head(sort2) #покажем итоговый результат
```
# Задание №6

>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Оставьте только колонки, имена которых начинаются с буквы ***d**. Примените связку **select() + starts_with()**

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sort_d <-select(sq,starts_with("d")) # выберем из подвыборки рейсов из задания №4 колонки, имена которых начинаются с буквы d.
head(sort_d)
```

# Задание №7

>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Оставьте только такие колонки, которые в названии содержат “_” в любом месте. Примените связку **select() + contains()**

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sort__ <- select(sq,contains("_")) # выберем из подвыборки рейсов из задания №4 колонки, имена которых в названии содержат “_” в любом месте.
head(sort__)
```
# Задание №8

>Отбирать строки по позициям можно с помощью **функции slice()**
>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Отберите первую, пятую и десятую строки.

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq %>%
  slice(c(1,5,10)) # отберем 1,5,10 строки
```
# Задание №9

>Для вывода шапки набора данных можно использовать, например, **функцию slice_head()**, аналог **функции head()** из базового R.

>Отберите первые 8 строк из полного набора данных **nycflights**.

```{r}
slice_head(nycflights,n=8) # отберем первые 8 строк
```
# Задание №10

>**Функция slice_sample()** помогает сделать случайный выбор строк разными способами.

>Выберите случайным образом 10 строк из полного набора данных **nycflights**.

```{r}
set.seed(123) # установим значение генератора для воспроизводимости
slice_sample(nycflights,n=10) # выберем случайным образом 10 строк
```

# Задание №11

>Отберите случайным образом **10% строк** из набора данных **nycflights**.
>Для выполнения задания исследуйте параметры **функции slice_sample()**.

```{r}
set.seed(123) # установим значение генератора для воспроизводимости
slice_sample(nycflights,prop = 0.1) # отоберем случайным образом 10% строк
```

# Задание №12

>Обратите внимание на **параметр weight_by функции slice_sample()**.

>Для чего он нужен? Продемонстрируйте его работу на любом примере.

***

> **Параметр weight_by** в **функции slice_sample()** используется для взвешивания вероятности выбора каждого элемента при выборке из набора данных. Это означает, что, когда вы используете этот параметр, каждый элемент в вашем наборе данных будет иметь разные вероятности быть выбранным в зависимости от значения, которое вы установите с помощью **weight_by**.

```{r}
# Создание примера набора данных
data <- data.frame(
  x = c(1, 2, 3, 4, 5),
  y = c(5, 4, 3, 2, 1)
)

# Применение slice_sample с параметром weight_by
set.seed(123)
result <- data %>%
  slice_sample(n = 2, weight_by = y)
result
```
>В этом примере **slice_sample()** выбирает два элемента из набора данных data. **Параметр weight_by = y **означает, что вероятность выбора каждого элемента прямо пропорциональна его значению y. Таким образом, строка с y = 5 имеет наибольшую вероятность быть выбранной, а строка с y = 1 - наименьшую.

# Задание №13

>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.
>Выберите столбец **tailnum** двумя способами: с помощью **функций pull() и select()**.
>В чем разница?

```{r}
head(sort_flights) # подвыборка рейсов из задания №4(не подходит, так как там нет столбца tailnum, поэтому выбираю подвыборку рейсов из задания №3)
sq <- sort_flights
sq %>%
  select(tailnum) %>% head(5) #выбираем с помощью select
sq %>%
  pull(tailnum) %>% head(5) #выбираем с помощью pull
```
>**pull()** используется для извлечения одного столбца из набора данных и возвращает его как вектор.

>**select()** используется для выбора одного или нескольких столбцов из набора данных и возвращает их как новый набор данных.

# Задание №14

>С помощью **функции arrange()** можно отсортировать данные по одному или нескольким столбцам по убыванию ли возрастанию.
>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Отсортируйте набор данных по столбцу **day** по **убыванию**.

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq %>%
  arrange(desc(day)) # отсортируем набор данных по столбцу day по убыванию

```
# Задание №15

>Добавить новый столбец к набору данных можно с помощью **функции mutate()**.
>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Добавьте к данным столбец YMD, который представляет собой слияние столбцов **year, month, day вида: year_month_day (пример: 2023_9_18)**.

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq %>%
  mutate(YMD = paste(year,month,day, sep="_")) %>% head(3) # добавим к данным столбец YMD c указанным форматом
```
# Задание №16

>С помощью **функции transmute()** можно создать новые колонки, удалив при этом все колонки, которые были раньше.
>Воспользуйтесь исходными данными **nycflights**.
>Создайте и оставьте только колонки:

>**YMD**: аналогичная описанной в задании №15

>**dep_delay_abs**: абсолютные значения колонки dep_delay

>**arr_delay_abs**: абсолютные значения колонки arr_delay.

```{r}
nycflights %>%
  transmute(YMD = paste(year,month,day,sep="_"), #используем transmute()
            dep_delay_abs = abs(dep_delay), # берем абсолютные значения dep и arr _delay
            arr_delay_abs = abs(arr_delay)) %>% head(3)
```
# Задание №17

>Переименовать колонки можно с помощью **функции rename()**.
Воспользуйтесь исходными данными **nycflights**.

>Переименуйте колонку **dep_delay** в **Departure_delays_min**.

```{r}
nycflights %>%
  rename(Departure_delays_min = dep_delay) %>% head(3) # переименуем столбец
```
# Задание №18

>Переименовать колонки можно, применив к названиям какую-то единообразную операцию.Это можно сделать с помощью **функции rename_with()**.
Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Сделайте все буквы в названиях всех колонок **заглавными**.

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq %>%
  rename_with(.fn = toupper) # используем функцию toupper, которая делает все буквы заглавными
```

# Задание №19

>Оставить только уникальные строки в наборе данных или в конкретном столбце можно с помощью **функции distinct()**.
>Воспользуйтесь подвыборкой рейсов, полученных в задании №4.

>Выведите только уникальные значения столбца **dest**.

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq %>%
  distinct(dest) # выведем уникальные значения столбца dest
```
# Задание №20

>**n()** - выводит число записей.

>Отберите **последние 10 строк** из набора данных **nycflights**, используя **функцию n()**.

```{r}
nycflights %>%
  slice((n() - 9):n()) # отберем последние 10 строк с помощью n()
```

# Задание №21

>Воспользуйтесь полным набором данных **nycflights**.
>С помощью средств базовой графики **визуализируйте количество рейсов в каждом месяце**.

>Подпишите оси и название графика.

```{r}
barplot(table(nycflights$month), main = "Количество рейсов в каждом месяце", xlab = "Месяц", ylab = "Количество рейсов") # построим столбчатую диаграмму по месяцам.
```

# Задание №22

>Воспользуйтесь полным набором данных **nycflights**.
>С помощью средств базовой графики* *визуализируйте распределение времени задержки прибытия рейса (столбец arr_delay)**.

>Подпишите оси и название графика.

```{r}
hist(nycflights$arr_delay, 
     main="Распределение времени задержки прибытия рейса", 
     xlab="Время задержки", 
     ylab="Количество рейсов", 
     col="lightblue", 
     border="black") # построим гистаграмму для этого
```

# Задание №23

>Воспользуйтесь полным набором данных **nycflights**.
С помощью средств базовой графики **изобразите точковую диаграмму времени задержки отправления от задержки прибытия рейсов**. Добавьте **окрашивание по месяцам**.

>Подпишите оси и название графика.

```{r}
plot(nycflights$arr_delay, nycflights$dep_delay, cex = 2, pch = 16,col = nycflights$month,
     main="Точковая диаграмма времени задержки отправления от задержки прибытия рейсов", 
     xlab="Время задержки прибытия", 
     ylab="Время задержки отправления") #строим точковую диаграмму

# Получим уникальные значения цветов
unique_colors <- unique(nycflights$month)

# Добавим легенду
legend("right", legend = unique_colors, col = unique_colors, pch = 16, cex = 1.2)
# PS: позади легенды есть точка:)
```

# Задание №24

>Решите задание №3 с помощью базового R.

>Отберите из набора данных ***nycflights** **июньские** (столбец month) рейсы, которые вылетели (столбец origin) из аэропорта **JFK** и прилетели (столбец dest) в аэропорты **LAX** или **ROC**. Выполните фильтрацию за одну команду. Покажите, что вы точно отобрали только нужные аэропорты.

>Сколько рейсов подходят под условия?

```{r}
sort_flights <- nycflights[nycflights$month == 6 & nycflights$origin == 'JFK' & (nycflights$dest == "LAX" | nycflights$dest == "ROC"),] # отберем данные по условию
#Убедимся, что мы точно отобрали, то что нужно
table(sort_flights$month)
table(sort_flights$origin)
table(sort_flights$dest)
dim(sort_flights)[1] # столько рейсов подходят под условия
```

# Задание №25

>>Добавьте к данным столбец YMD, который представляет собой слияние столбцов year, month, day вида: year_month_day (пример: 2023_9_18).

```{r}
head(super_sort) # подвыборка рейсов из задания №4
sq <- super_sort
sq["YMD"] = paste(sq$year,sq$month,sq$day, sep="_") # добавим к данным столбец YMD c указанным форматом
head(sq,3)
```